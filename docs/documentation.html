<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- SEO Meta Tags -->
  <title>Documentation - Agent Orcha | Multi-Agent AI Framework</title>
  <meta name="description" content="Complete documentation for Agent Orcha. Learn agents, workflows, knowledge stores, ReAct workflows, MCP integration, and custom functions with YAML configuration.">
  <meta name="keywords" content="agent orcha documentation, multi-agent AI, YAML configuration, MCP tools, RAG, knowledge stores, ReAct workflows">
  <meta name="author" content="Agent Orcha">

  <!-- Open Graph Tags -->
  <meta property="og:title" content="Documentation - Agent Orcha">
  <meta property="og:description" content="Complete documentation for building multi-agent AI systems with Agent Orcha.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://ddalcu.github.io/agent-orcha/documentation.html">

  <!-- Twitter Card Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Documentation - Agent Orcha">
  <meta name="twitter:description" content="Complete documentation for building multi-agent AI systems.">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:wght@600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer">

  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css">

  <!-- Styles -->
  <link rel="stylesheet" href="assets/css/styles.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="nav">
    <div class="nav-container">
      <a href="index.html" class="nav-logo">
        <img src="assets/images/logo-only.png" alt="Agent Orcha Logo">
        <span>Agent Orcha</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">☰</button>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="documentation.html">Documentation</a></li>
        <li><a href="hub.html">Hub</a></li>
        <li><a href="https://github.com/ddalcu/agent-orcha" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> GitHub</a></li>
        <li><a href="https://www.npmjs.com/package/agent-orcha" target="_blank" rel="noopener"><i class="fa-brands fa-npm"></i> NPM</a></li>
      </ul>
    </div>
  </nav>


  <!-- Documentation Content -->
  <section class="section">
    <div class="docs-layout">
      <!-- Left Sidebar Navigation -->
      <aside class="docs-sidebar">
        <nav class="docs-nav">
          <h4>Getting Started</h4>
          <ul>
            <li><a href="#quick-start">Quick Start Guide (Docker)</a></li>
            <li><a href="#studio">Agent Orcha Studio</a></li>
            <li><a href="#docker">Docker Reference</a></li>
            <li><a href="#cli-reference">CLI (npx alternative)</a></li>
          </ul>

          <h4>Core Concepts</h4>
          <ul>
            <li><a href="#core-concepts">Overview</a></li>
            <li><a href="#agents">Agents</a></li>
            <li><a href="#structured-output">Structured Output</a></li>
            <li><a href="#conversation-memory">Conversation Memory</a></li>
            <li><a href="#workflows">Workflows</a></li>
            <li><a href="#react-workflows">ReAct Workflows</a></li>
            <li><a href="#functions">Functions</a></li>
            <li><a href="#mcp-servers">MCP Servers</a></li>
            <li><a href="#skills">Skills</a></li>
            <li><a href="#tasks">Tasks</a></li>
            <li><a href="#sandbox">Sandbox</a></li>
            <li><a href="#persistent-memory">Persistent Memory</a></li>
            <li><a href="#triggers">Triggers</a></li>
            <li><a href="#integrations">Integrations</a>
              <ul>
                <li><a href="#integration-collabnook">Collabnook</a></li>
                <li><a href="#integration-email">Email</a></li>
              </ul>
            </li>
            <li><a href="#published-agents">Published Agents</a></li>
          </ul>

          <h4>Knowledge Stores</h4>
          <ul>
            <li><a href="#knowledge-stores">Overview</a></li>
            <li><a href="#knowledge-schema">Schema</a></li>
            <li><a href="#direct-mapping">Direct Mapping (Graph)</a></li>
            <li><a href="#source-types">Source Types</a></li>
            <li><a href="#search-configuration">Search Configuration</a></li>
            <li><a href="#direct-sql-querying">Direct SQL Querying</a></li>
          </ul>

          <h4>API Reference</h4>
          <ul>
            <li><a href="#api-reference">Overview</a></li>
            <li>
              <ul>
                <li><a href="#auth-api">Authentication API</a></li>
                <li><a href="#agents-api">Agents API</a></li>
                <li><a href="#chat-api">Chat API (Published Agents)</a></li>
                <li><a href="#workflows-api">Workflows API</a></li>
                <li><a href="#knowledge-api">Knowledge API</a></li>
                <li><a href="#functions-api">Functions API</a></li>
                <li><a href="#skills-api">Skills API</a></li>
                <li><a href="#tasks-api">Tasks API</a></li>
                <li><a href="#mcp-api">MCP API</a></li>
                <li><a href="#files-api">Files API</a></li>
                <li><a href="#llm-api">LLM API</a></li>
              </ul>
            </li>
          </ul>

          <h4>Examples</h4>
          <ul>
            <li><a href="#examples">Code Examples</a></li>
          </ul>
        </nav>
      </aside>

      <!-- Main Content -->
      <div class="docs-content">

        <!-- Quick Start Guide -->
        <h2 id="quick-start">Quick Start Guide</h2>
        <p>Get started with Agent Orcha in minutes using Docker (recommended). Follow these steps to set up your first multi-agent system.</p>

        <div class="expandable active">
          <div class="expandable-header">
            <h3>Step 1: Initialize Your Project</h3>
            <span class="expandable-icon">▼</span>
          </div>
          <div class="expandable-content">
            <div class="expandable-body">
              <p>Create a new Agent Orcha project with example configurations:</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">Bash</span>
                  <button class="code-copy-btn" data-copy-target="init-cmd">Copy</button>
                </div>
                <div class="code-content">
                  <pre id="init-cmd"><code>docker run -v ./my-project:/data ddalcu/agent-orcha init</code></pre>
                </div>
              </div>
              <p>This creates a project directory with:</p>
              <ul>
                <li><code>agents/</code> - Example agent configurations</li>
                <li><code>workflows/</code> - Example workflow definitions</li>
                <li><code>functions/</code> - Custom JavaScript functions</li>
                <li><code>knowledge/</code> - Knowledge store configurations and data</li>
                <li><code>llm.json</code> - LLM provider settings</li>
                <li><code>mcp.json</code> - MCP server configuration</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="expandable">
          <div class="expandable-header">
            <h3>Step 2: Configure Your LLM</h3>
            <span class="expandable-icon">▼</span>
          </div>
          <div class="expandable-content">
            <div class="expandable-body">
              <p>Edit <code>llm.json</code> to configure your LLM providers. Agent Orcha supports OpenAI, Anthropic, Gemini, and local models.</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">JSON</span>
                  <button class="code-copy-btn" data-copy-target="llm-config">Copy</button>
                </div>
                <div class="code-content">
                  <pre id="llm-config"><code>{
  "version": "1.0",
  "models": {
    "default": {
      "provider": "openai",
      "baseUrl": "http://localhost:1234/v1",
      "apiKey": "not-needed",
      "model": "your-model-name",
      "temperature": 0.7
    },
    "openai": {
      "apiKey": "sk-your-openai-key",
      "model": "gpt-4o",
      "temperature": 0.7
    }
  },
  "embeddings": {
    "default": {
      "provider": "openai",
      "baseUrl": "http://localhost:1234/v1",
      "apiKey": "not-needed",
      "model": "text-embedding-model"
    }
  }
}</code></pre>
                </div>
              </div>
              <p><strong>For local models:</strong></p>
              <ul>
                <li><strong>LM Studio:</strong> Use <code>baseUrl: "http://localhost:1234/v1"</code></li>
                <li><strong>Ollama:</strong> Use <code>baseUrl: "http://localhost:11434/v1"</code></li>
              </ul>
            </div>
          </div>
        </div>

        <div class="expandable">
          <div class="expandable-header">
            <h3>Step 3: Create Your First Agent</h3>
            <span class="expandable-icon">▼</span>
          </div>
          <div class="expandable-content">
            <div class="expandable-body">
              <p>Create a new file <code>agents/myagent.agent.yaml</code>:</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">YAML</span>
                  <button class="code-copy-btn" data-copy-target="first-agent">Copy</button>
                </div>
                <div class="code-content">
                  <pre id="first-agent"><code>name: myagent
description: My first AI agent
version: "1.0.0"

llm:
  name: default
  temperature: 0.7

prompt:
  system: |
    You are a helpful assistant.
    Answer questions clearly and concisely.
  inputVariables:
    - query

output:
  format: text</code></pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="expandable">
          <div class="expandable-header">
            <h3>Step 4: Start the Server</h3>
            <span class="expandable-icon">▼</span>
          </div>
          <div class="expandable-content">
            <div class="expandable-body">
              <p>Launch the Agent Orcha server:</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">Bash</span>
                  <button class="code-copy-btn" data-copy-target="start-cmd">Copy</button>
                </div>
                <div class="code-content">
                  <pre id="start-cmd"><code>docker run -p 3000:3000 -e AUTH_PASSWORD=mypass -v ./my-project:/data ddalcu/agent-orcha start</code></pre>
                </div>
              </div>
              <p>The server and Studio dashboard will be available at <code>http://localhost:3000</code>.</p>
            </div>
          </div>
        </div>

        <div class="expandable">
          <div class="expandable-header">
            <h3>Step 5: Test Your Agent</h3>
            <span class="expandable-icon">▼</span>
          </div>
          <div class="expandable-content">
            <div class="expandable-body">
              <p>Invoke your agent via the REST API:</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">Bash</span>
                  <button class="code-copy-btn" data-copy-target="test-agent">Copy</button>
                </div>
                <div class="code-content">
                  <pre id="test-agent"><code>curl -X POST http://localhost:3000/api/agents/myagent/invoke \
  -H "Content-Type: application/json" \
  -d '{"input": {"query": "Hello, how are you?"}}'</code></pre>
                </div>
              </div>
              <p>Expected response:</p>
              <div class="code-block">
                <div class="code-header">
                  <span class="code-language">JSON</span>
                </div>
                <div class="code-content">
                  <pre><code>{
  "output": "Hello! I'm doing well, thank you...",
  "metadata": {
    "tokensUsed": 42,
    "toolCalls": [],
    "duration": 823
  }
}</code></pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Agent Orcha Studio -->
        <h3 id="studio" class="mt-xl">Agent Orcha Studio</h3>
        <p>Agent Orcha includes a built-in web dashboard accessible at <code>http://localhost:3000</code> when the server is running. The Studio provides a visual interface for managing and testing your entire instance. When <code>AUTH_PASSWORD</code> is set, the Studio will prompt for the password before granting access.</p>

        <h4>Studio Tabs</h4>
        <table>
          <thead>
            <tr>
              <th>Tab</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Agents</strong></td>
              <td>Browse all agents, invoke with custom input, stream responses, manage conversation sessions</td>
            </tr>
            <tr>
              <td><strong>Knowledge</strong></td>
              <td>Browse and search knowledge stores, view entities and graph structure for stores with direct mapping</td>
            </tr>
            <tr>
              <td><strong>MCP</strong></td>
              <td>Browse MCP servers, view available tools per server, call tools directly</td>
            </tr>
            <tr>
              <td><strong>Workflows</strong></td>
              <td>Browse and execute workflows (step-based and ReAct), stream execution progress, respond to Human-in-the-Loop prompts</td>
            </tr>
            <tr>
              <td><strong>Skills</strong></td>
              <td>Browse and inspect available skills attached to agents</td>
            </tr>
            <tr>
              <td><strong>Monitor</strong></td>
              <td>View LLM call logs with context size, token estimates, and duration metrics</td>
            </tr>
            <tr>
              <td><strong>IDE</strong></td>
              <td>Full in-browser file editor with file tree, syntax highlighting (YAML, JSON, JS), hot-reload on save</td>
            </tr>
          </tbody>
        </table>

        <!-- Docker Reference -->
        <h3 id="docker" class="mt-xl">Docker Reference</h3>
        <p>Docker is the recommended way to run Agent Orcha. The <code>ddalcu/agent-orcha</code> image includes everything you need — no Node.js installation required.</p>

        <h4>Initialize a Project via Docker</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="docker-init">Copy</button>
          </div>
          <div class="code-content">
            <pre id="docker-init"><code>docker run -v ./my-agent-orcha-project:/data ddalcu/agent-orcha init</code></pre>
          </div>
        </div>

        <h4>Start the Server via Docker</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="docker-start">Copy</button>
          </div>
          <div class="code-content">
            <pre id="docker-start"><code>docker run -p 3000:3000 -e AUTH_PASSWORD=mypass -v ./my-agent-orcha-project:/data ddalcu/agent-orcha start</code></pre>
          </div>
        </div>

        <h4>Docker Compose</h4>
        <p>For a more manageable setup, use a <code>docker-compose.yaml</code> file:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="docker-compose">Copy</button>
          </div>
          <div class="code-content">
            <pre id="docker-compose"><code>services:
  agent-orcha:
    image: ddalcu/agent-orcha
    ports:
      - "3000:3000"
    volumes:
      - ./my-agent-orcha-project:/data
    environment:
      AUTH_PASSWORD: mypass</code></pre>
          </div>
        </div>

        <h4>Environment Variables</h4>
        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Description</th>
              <th>Default</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>WORKSPACE</code></td>
              <td>Base directory for the project inside the container</td>
              <td><code>/data</code></td>
            </tr>
            <tr>
              <td><code>PORT</code></td>
              <td>Port for the server to listen on</td>
              <td><code>3000</code></td>
            </tr>
            <tr>
              <td><code>AUTH_PASSWORD</code></td>
              <td>When set, all API routes and the Studio UI require this password to access. When unset, no authentication is required.</td>
              <td><em>unset (no auth)</em></td>
            </tr>
            <tr>
              <td><code>BROWSER_SANDBOX</code></td>
              <td>When <code>true</code>, starts Chromium + Xvfb + VNC inside the container for browser sandbox tools. The VNC viewer is accessible through the Studio UI at <code>/vnc</code>.</td>
              <td><code>true</code></td>
            </tr>
          </tbody>
        </table>

        <!-- CLI Commands (npx alternative) -->
        <h3 id="cli-reference" class="mt-xl">CLI Commands (npx alternative)</h3>
        <p>If you prefer not to use Docker, you can run Agent Orcha directly via <code>npx</code> (requires Node.js 24+).</p>

        <table>
          <thead>
            <tr>
              <th>Command</th>
              <th>Description</th>
              <th>Options</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>npx agent-orcha init [dir]</code></td>
              <td>Initialize a new project with example configs</td>
              <td><code>dir</code> - Target directory (default: current)</td>
            </tr>
            <tr>
              <td><code>npx agent-orcha start</code></td>
              <td>Start the agent orchestrator server</td>
              <td>Environment variables: <code>PORT</code>, <code>HOST</code>, <code>WORKSPACE</code></td>
            </tr>
            <tr>
              <td><code>npx agent-orcha help</code></td>
              <td>Show help information</td>
              <td>-</td>
            </tr>
          </tbody>
        </table>

        <!-- Core Concepts -->
        <h2 id="core-concepts" class="mt-2xl">Core Concepts</h2>

        <p>The diagram below shows how the major components fit together &mdash; from input sources through the orchestrator to tool execution.</p>
        <img src="architecture.svg" alt="Agent Orcha Architecture" style="width:100%;margin:1.5rem 0;" />

        <h3 id="agents">Agents</h3>
        <p>Agents are AI-powered units that can use tools and respond to queries. Each agent is defined in a YAML file with its configuration.</p>

        <h4>Agent Schema</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="agent-schema">Copy</button>
          </div>
          <div class="code-content">
            <pre id="agent-schema"><code>name: string                    # Unique identifier (required)
description: string             # Human-readable description (required)
version: string                 # Semantic version (default: "1.0.0")

llm: string | object            # Reference to LLM config in llm.json
  # Simple: llm: default
  # With override: llm: { name: default, temperature: 0.3 }

prompt:                         # Prompt configuration (required)
  system: string                # System message/instructions
  inputVariables: [string]      # Variables to interpolate

tools:                          # Tools available to agent (optional)
  - mcp:&lt;server-name&gt;           # MCP server tools
  - knowledge:&lt;store-name&gt;      # Knowledge store search
  - function:&lt;function-name&gt;    # Custom functions
  - builtin:&lt;tool-name&gt;         # Built-in tools (e.g., ask_user)
  - sandbox:&lt;tool-name&gt;         # Sandbox tools (exec, shell, browser, web)

skills:                         # Skills to inject into system prompt (optional)
  - skill-name                  # Array of skill names
  # Or: skills: { mode: all }   # Attach all available skills

memory: boolean | object        # Persistent memory across sessions (optional)
  # Simple: memory: true
  # With options: memory: { enabled: true, maxLines: 100 }

output:                         # Output formatting (optional)
  format: text | structured
  schema:                       # Required when format is "structured"
    type: object
    properties: { ... }
    required: [string]

metadata:                       # Custom metadata (optional)
  category: string
  tags: [string]

triggers:                       # Automatic execution triggers (optional)
  - type: cron
    schedule: "0 9 * * *"       # Cron expression
    input: { key: value }       # Input for the agent
  - type: webhook
    path: /api/triggers/webhooks/my-hook
    input: { key: value }       # Base input (merged with request body)

integrations:                   # External connectors (optional)
  - type: collabnook            # Chat platform connector
    url: https://collabnook.example.com
    channel: general
    botName: orcha-bot
  - type: email                 # Email connector (IMAP + SMTP)
    imap: { host: imap.gmail.com, port: 993, secure: true }
    smtp: { host: smtp.gmail.com, port: 587, secure: false }
    auth: { user: agent@example.com, pass: app-password }

publish: boolean | object       # Standalone chat page (optional)
  # Simple: publish: true
  # With password: publish: { enabled: true, password: "secret" }</code></pre>
          </div>
        </div>

        <h4>Example Agent with Tools</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="agent-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="agent-example"><code>name: researcher
description: Researches topics using knowledge search and web fetch
version: "1.0.0"

llm:
  name: default
  temperature: 0.5

prompt:
  system: |
    You are a thorough researcher. Use available tools
    to gather information before responding.
  inputVariables:
    - topic

tools:
  - mcp:fetch
  - knowledge:docs
  - function:fibonacci

output:
  format: text

metadata:
  category: research</code></pre>
          </div>
        </div>

        <h3 id="structured-output" class="mt-xl">Structured Output</h3>
        <p>Agents can return validated, structured JSON output by specifying an <code>output.schema</code>. This ensures responses match your schema with automatic validation.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="structured-output">Copy</button>
          </div>
          <div class="code-content">
            <pre id="structured-output"><code>name: sentiment-structured
description: Sentiment analysis with structured output

llm:
  name: default
  temperature: 0

prompt:
  system: |
    Analyze the sentiment of the provided text.
  inputVariables:
    - text

output:
  format: structured
  schema:
    type: object
    properties:
      sentiment:
        type: string
        enum: [positive, negative, neutral]
      confidence:
        type: number
        minimum: 0
        maximum: 1
      keywords:
        type: array
        items:
          type: string
    required:
      - sentiment
      - confidence</code></pre>
          </div>
        </div>

        <h3 id="conversation-memory" class="mt-xl">Conversation Memory</h3>
        <p>Agents support session-based conversation memory for multi-turn dialogues. Pass a <code>sessionId</code> in API calls to maintain context across interactions.</p>
        <ul>
          <li>In-memory session storage with custom message types</li>
          <li>Automatic FIFO message limit (default: 50 messages per session)</li>
          <li>Optional TTL-based session cleanup</li>
          <li>Session management API endpoints for stats and cleanup</li>
        </ul>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="memory-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="memory-example"><code># First message with sessionId
curl -X POST http://localhost:3000/api/agents/chatbot/invoke \
  -H "Content-Type: application/json" \
  -d '{"input": {"message": "My name is Alice"}, "sessionId": "user-123"}'

# Second message - agent remembers context
curl -X POST http://localhost:3000/api/agents/chatbot/invoke \
  -H "Content-Type: application/json" \
  -d '{"input": {"message": "What is my name?"}, "sessionId": "user-123"}'</code></pre>
          </div>
        </div>

        <h3 id="workflows" class="mt-xl">Workflows</h3>
        <p>Workflows orchestrate multiple agents. Agent Orcha supports two workflow types: <strong>step-based</strong> (sequential/parallel with explicit steps) and <strong>ReAct</strong> (autonomous, prompt-driven).</p>

        <h4>Step-Based Workflow Schema</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="workflow-schema">Copy</button>
          </div>
          <div class="code-content">
            <pre id="workflow-schema"><code>name: string                    # Unique identifier (required)
description: string             # Human-readable description (required)
version: string                 # Semantic version (default: "1.0.0")
type: steps                     # Optional (steps is default)

input:                          # Input schema (required)
  schema:
    &lt;field_name&gt;:
      type: string | number | boolean | array | object
      required: boolean
      default: any
      description: string

steps:                          # Workflow steps (required)
  - id: string                  # Unique step identifier
    agent: string               # Agent name to execute
    input:                      # Input mapping using templates
      &lt;key&gt;: "{{input.field}}"
      &lt;key&gt;: "{{steps.stepId.output}}"
    condition: string           # Optional conditional execution
    retry:                      # Optional retry configuration
      maxAttempts: number
      delay: number
    output:
      key: string

  # Parallel execution block
  - parallel:
      - id: step-a
        agent: agent-a
        input: { ... }

config:                         # Workflow configuration (optional)
  timeout: number               # Total timeout ms (default: 300000)
  onError: stop | continue | retry

output:                         # Output mapping (required)
  &lt;key&gt;: "{{steps.stepId.output}}"</code></pre>
          </div>
        </div>

        <h4>Template Syntax</h4>
        <p>Access data within workflows using double curly braces:</p>
        <table>
          <thead>
            <tr>
              <th>Template</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>{{input.fieldName}}</code></td>
              <td>Access workflow input field</td>
            </tr>
            <tr>
              <td><code>{{steps.stepId.output}}</code></td>
              <td>Access step output</td>
            </tr>
            <tr>
              <td><code>{{steps.stepId.output.nested.path}}</code></td>
              <td>Access nested output</td>
            </tr>
            <tr>
              <td><code>{{steps.stepId.metadata.duration}}</code></td>
              <td>Access step metadata</td>
            </tr>
          </tbody>
        </table>

        <h3 id="react-workflows" class="mt-xl">ReAct Workflows</h3>
        <p>ReAct workflows use autonomous agents that discover and call tools/agents based on your prompt, without explicit step definitions.</p>

        <h4>ReAct Schema</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="react-schema">Copy</button>
          </div>
          <div class="code-content">
            <pre id="react-schema"><code>name: string
type: react                     # Required for ReAct

input:
  schema:
    &lt;field&gt;:
      type: string
      required: true

prompt:
  system: string                # System instructions
  goal: string                  # Goal template (supports {{input.*}})

graph:
  model: string                 # LLM config name from llm.json
  executionMode: react | single-turn  # Default: react
  tools:
    mode: all | include | exclude | none
    sources: [mcp, knowledge, function, builtin]
    include: [string]           # For mode: include
    exclude: [string]           # For mode: exclude
  agents:
    mode: all | include | exclude | none
  maxIterations: number         # Default: 10
  timeout: number               # Default: 300000

output:
  &lt;key&gt;: "{{state.messages[-1].content}}"</code></pre>
          </div>
        </div>

        <h4>Execution Modes</h4>
        <table>
          <thead>
            <tr>
              <th>Mode</th>
              <th>Behavior</th>
              <th>Best For</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>single-turn</code></td>
              <td>Calls tools once, then returns</td>
              <td>Research, data gathering, straightforward tasks</td>
            </tr>
            <tr>
              <td><code>react</code></td>
              <td>Multiple rounds of tool calls with analysis</td>
              <td>Complex problems, iterative refinement</td>
            </tr>
          </tbody>
        </table>

        <h4>Human-in-the-Loop</h4>
        <p>ReAct workflows support the <code>builtin:ask_user</code> tool. When called, the workflow pauses and waits for user input. In the Studio Workflows tab, an inline input prompt appears automatically &mdash; type your response and the workflow resumes. You can also respond via the Monitor tab or the Tasks API (<code>POST /api/tasks/:id/respond</code>).</p>

        <h3 id="functions" class="mt-xl">Functions</h3>
        <p>Functions are custom JavaScript tools that extend agent capabilities. They're simple to create and require no dependencies.</p>

        <h4>Function Schema</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JavaScript</span>
            <button class="code-copy-btn" data-copy-target="function-schema">Copy</button>
          </div>
          <div class="code-content">
            <pre id="function-schema"><code>export default {
  name: 'function-name',
  description: 'What it does',

  parameters: {
    param1: {
      type: 'number',  // string | number | boolean | array | object | enum
      description: 'Parameter description',
      required: true,
      default: 0,
    },
  },

  execute: async ({ param1 }) => {
    // Your logic here
    return `Result: ${param1}`;
  },
};

export const metadata = {
  name: 'function-name',
  version: '1.0.0',
  author: 'Your Name',
  tags: ['category'],
};</code></pre>
          </div>
        </div>

        <h4>Example Function</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JavaScript</span>
            <button class="code-copy-btn" data-copy-target="fibonacci-func">Copy</button>
          </div>
          <div class="code-content">
            <pre id="fibonacci-func"><code>export default {
  name: 'fibonacci',
  description: 'Returns the nth Fibonacci number (0-based indexing)',

  parameters: {
    n: {
      type: 'number',
      description: 'The index (0-based, max 100)',
    },
  },

  execute: async ({ n }) => {
    if (n &lt; 0 || !Number.isInteger(n)) {
      throw new Error('Index must be a non-negative integer');
    }
    if (n > 100) {
      throw new Error('Index too large (max 100)');
    }

    if (n === 0) return 'Fibonacci(0) = 0';
    if (n === 1) return 'Fibonacci(1) = 1';

    let prev = 0, curr = 1;
    for (let i = 2; i &lt;= n; i++) {
      [prev, curr] = [curr, prev + curr];
    }

    return `Fibonacci(${n}) = ${curr}`;
  },
};</code></pre>
          </div>
        </div>

        <h3 id="mcp-servers" class="mt-xl">MCP Servers</h3>
        <p>Model Context Protocol (MCP) servers provide external tools to agents. Configure them in <code>mcp.json</code>.</p>

        <h4>MCP Configuration</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JSON</span>
            <button class="code-copy-btn" data-copy-target="mcp-config">Copy</button>
          </div>
          <div class="code-content">
            <pre id="mcp-config"><code>{
  "version": "1.0.0",
  "servers": {
    "fetch": {
      "transport": "streamable-http",
      "url": "https://remote.mcpservers.org/fetch/mcp",
      "description": "Web fetch capabilities",
      "timeout": 30000,
      "enabled": true
    },
    "filesystem": {
      "transport": "stdio",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
    }
  },
  "globalOptions": {
    "throwOnLoadError": false,
    "prefixToolNameWithServerName": true,
    "defaultToolTimeout": 30000
  }
}</code></pre>
          </div>
        </div>

        <!-- Skills -->
        <h3 id="skills" class="mt-xl">Skills</h3>
        <p>Skills are prompt augmentation units that expand what an agent knows how to do. Unlike tools or functions, skills are <strong>not executable code</strong> &mdash; they are knowledge and instruction bundles (Markdown files) that get injected into an agent's system prompt at runtime.</p>

        <h4>Directory Structure</h4>
        <p>Each skill lives in its own directory under <code>skills/</code>:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code>skills/
  orcha-builder/
    SKILL.md
  pii-guard/
    SKILL.md
  sandbox/
    SKILL.md
  web-pilot/
    SKILL.md</code></pre>
          </div>
        </div>

        <h4>SKILL.md Format</h4>
        <p>A SKILL.md file has optional YAML frontmatter followed by Markdown content:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Markdown</span>
          </div>
          <div class="code-content">
            <pre><code>---
name: pii-guard
description: PII and OWASP security filtering rules
---

# PII Guard

## Sensitive Data Categories (NEVER include in responses)

- SSN, tax IDs, government identifiers
- Salary, compensation, financial data
- Home addresses, personal phone numbers
- Dates of birth, ages
- Full email addresses (mask as j***@company.com)</code></pre>
          </div>
        </div>

        <p>The frontmatter fields:</p>
        <ul>
          <li><strong>name</strong> &mdash; Unique skill identifier. If omitted, the directory name is used.</li>
          <li><strong>description</strong> &mdash; Human-readable description shown in the UI and API.</li>
        </ul>

        <h4>Agent Configuration</h4>
        <p>Attach skills to agents in their YAML definition file:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code># Specific skills by name
name: corporate
description: Friendly corporate assistant
llm: default
prompt:
  system: You are a friendly corporate assistant.
  inputVariables:
    - query
skills:
  - pii-guard

# Or attach all available skills
skills:
  mode: all</code></pre>
          </div>
        </div>

        <h4>How It Works</h4>
        <p>When an agent with skills is invoked, the skill content is appended to the agent's system prompt before the LLM call. Each skill is wrapped in <code>&lt;skill name="..."&gt;</code> delimiters so the LLM can distinguish between different skill instructions.</p>

        <h4>Creating Custom Skills</h4>
        <ol>
          <li>Create a directory under <code>skills/</code> with your skill name.</li>
          <li>Add a <code>SKILL.md</code> file with frontmatter and instructions.</li>
          <li>Reference the skill name in your agent's <code>skills</code> array.</li>
          <li>Restart the server or use hot-reload to pick up changes.</li>
        </ol>

        <h4>Community Skills Registry</h4>
        <p>Community-contributed skills that you can copy into your project:</p>
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Description</th>
              <th>Author</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>orcha-builder</strong></td>
              <td>Documentation for creating and modifying ORCHA resources</td>
              <td>Agent Orcha</td>
            </tr>
            <tr>
              <td><strong>pii-guard</strong></td>
              <td>PII and OWASP security filtering rules</td>
              <td>Agent Orcha</td>
            </tr>
            <tr>
              <td><strong>sandbox</strong></td>
              <td>JavaScript sandbox, shell, web fetch, and browser tools</td>
              <td>Agent Orcha</td>
            </tr>
            <tr>
              <td><strong>web-pilot</strong></td>
              <td>Browser automation via observe-act loop with element refs</td>
              <td>Agent Orcha</td>
            </tr>
          </tbody>
        </table>
        <p>Want to contribute a skill? Add it to <code>templates/skills/</code> and submit a pull request to the repository.</p>

        <!-- Tasks -->
        <h3 id="tasks" class="mt-xl">Tasks</h3>
        <p>Tasks provide async execution for agents and workflows. Submit a task, poll its status, stream updates via SSE, or cancel it. Tasks are managed in-memory with automatic cleanup.</p>

        <h4>Task Lifecycle</h4>
        <p>Tasks progress through these statuses:</p>
        <p><code>submitted</code> &rarr; <code>working</code> &rarr; <code>completed</code> | <code>failed</code> | <code>canceled</code></p>
        <p>ReAct workflows may also reach <code>input-required</code> when the <code>builtin:ask_user</code> tool is called, pausing until you respond via the API.</p>

        <h4>Submit a Task</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code># Submit an agent task
curl -X POST http://localhost:3000/api/tasks/agent \
  -H "Content-Type: application/json" \
  -d '{
    "agent": "researcher",
    "input": {"topic": "AI trends"},
    "sessionId": "optional-session-id"
  }'

# Submit a workflow task
curl -X POST http://localhost:3000/api/tasks/workflow \
  -H "Content-Type: application/json" \
  -d '{
    "workflow": "research-paper",
    "input": {"topic": "AI trends"}
  }'</code></pre>
          </div>
        </div>

        <h4>Stream Task Status (SSE)</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code>curl -N http://localhost:3000/api/tasks/TASK_ID/stream</code></pre>
          </div>
        </div>

        <h4>Respond to Input Request</h4>
        <p>When a ReAct workflow reaches <code>input-required</code>, respond to continue execution:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code>curl -X POST http://localhost:3000/api/tasks/TASK_ID/respond \
  -H "Content-Type: application/json" \
  -d '{"response": "Yes, proceed with option A"}'</code></pre>
          </div>
        </div>

        <!-- Sandbox -->
        <h3 id="sandbox" class="mt-xl">Sandbox</h3>
        <p>The sandbox system provides isolated execution environments for agents. It includes tools for JavaScript execution, shell commands, web interaction, and browser automation.</p>

        <h4>Configuration</h4>
        <p>Configure sandbox behavior in <code>sandbox.json</code> (optional &mdash; defaults to enabled):</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JSON</span>
          </div>
          <div class="code-content">
            <pre><code>{
  "enabled": true,
  "commandTimeout": 30000,
  "maxOutputChars": 50000,
  "browserCdpUrl": "http://localhost:9222"
}</code></pre>
          </div>
        </div>

        <h4>Sandbox Tools</h4>
        <table>
          <thead>
            <tr>
              <th>Tool</th>
              <th>Description</th>
              <th>Parameters</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>sandbox:exec</code></td>
              <td>Execute JavaScript code in a sandboxed VM</td>
              <td><code>code</code> (string), <code>timeout</code> (number, optional)</td>
            </tr>
            <tr>
              <td><code>sandbox:shell</code></td>
              <td>Execute shell commands as a non-root <code>sandbox</code> user</td>
              <td><code>command</code> (string), <code>timeout</code> (number, optional)</td>
            </tr>
            <tr>
              <td><code>sandbox:web_fetch</code></td>
              <td>Fetch a web page and convert HTML to Markdown</td>
              <td><code>url</code> (string), <code>raw</code> (boolean, optional)</td>
            </tr>
            <tr>
              <td><code>sandbox:web_search</code></td>
              <td>Search the web via DuckDuckGo</td>
              <td><code>query</code> (string), <code>num_results</code> (number, optional)</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_navigate</code></td>
              <td>Navigate the browser to a URL and wait for page load</td>
              <td><code>url</code> (string)</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_observe</code></td>
              <td>Get a text snapshot of the current page (accessibility tree)</td>
              <td>&mdash;</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_click</code></td>
              <td>Click an element by CSS selector</td>
              <td><code>selector</code> (string)</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_type</code></td>
              <td>Type text into a focused element</td>
              <td><code>selector</code> (string), <code>text</code> (string)</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_screenshot</code></td>
              <td>Take a screenshot (returns image to the LLM as a multimodal content part)</td>
              <td>&mdash;</td>
            </tr>
            <tr>
              <td><code>sandbox:browser_evaluate</code></td>
              <td>Execute JavaScript in the browser page context</td>
              <td><code>expression</code> (string)</td>
            </tr>
          </tbody>
        </table>

        <h4>Browser Sandbox (Docker)</h4>
        <p>Browser tools require Chromium running inside the Docker container. Set <code>BROWSER_SANDBOX=true</code> (enabled by default in the Docker image) to start Xvfb + Chromium + VNC automatically. The VNC viewer is accessible through the Studio UI at <code>/vnc</code> (protected by <code>AUTH_PASSWORD</code> when set).</p>

        <h4>Using Sandbox Tools in Agents</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: code-runner
description: Agent that can execute code and search the web
llm: default

prompt:
  system: |
    You can execute JavaScript code and search the web.
  inputVariables:
    - task

tools:
  - sandbox:exec
  - sandbox:shell
  - sandbox:web_fetch
  - sandbox:web_search
  - sandbox:browser_navigate
  - sandbox:browser_observe
  - sandbox:browser_click
  - sandbox:browser_type
  - sandbox:browser_screenshot
  - sandbox:browser_evaluate</code></pre>
          </div>
        </div>

        <!-- Persistent Memory -->
        <h3 id="persistent-memory" class="mt-xl">Persistent Memory</h3>
        <p>Agent Orcha has two memory layers. <strong>Conversation memory</strong> (session-based, in-memory) tracks multi-turn dialogues. <strong>Persistent memory</strong> saves facts to disk so agents remember across sessions and server restarts.</p>

        <h4>Agent Configuration</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: assistant
description: Agent with persistent memory
llm: default

prompt:
  system: |
    You are a helpful assistant. Save important facts
    about the user to your memory for future sessions.
  inputVariables:
    - message

memory: true        # Enable persistent memory</code></pre>
          </div>
        </div>

        <h4>How It Works</h4>
        <ul>
          <li>When <code>memory: true</code>, the agent gets a <code>save_memory</code> built-in tool</li>
          <li>Memory is stored as Markdown files in <code>.memory/{agentName}.md</code></li>
          <li>On each invocation, prior memory is loaded and injected into the system prompt</li>
          <li>The agent decides what to remember by calling <code>save_memory</code></li>
        </ul>

        <!-- Triggers -->
        <h3 id="triggers" class="mt-xl">Triggers</h3>
        <p>Triggers allow agents to run automatically on a schedule (cron) or in response to external events (webhook).</p>

        <h4>Cron Trigger</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: daily-reporter
description: Runs every morning at 9am
llm: default

prompt:
  system: Generate a daily summary report.
  inputVariables:
    - task

triggers:
  - type: cron
    schedule: "0 9 * * *"
    input:
      task: "Generate the daily report"</code></pre>
          </div>
        </div>

        <h4>Webhook Trigger</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: webhook-handler
description: Responds to external webhook events
llm: default

prompt:
  system: Process the incoming webhook payload.
  inputVariables:
    - data

triggers:
  - type: webhook
    path: /api/triggers/webhooks/webhook-handler
    input:
      data: "default context"</code></pre>
          </div>
        </div>
        <p>Webhook triggers register a <code>POST</code> endpoint at the specified path. The request body is merged with the base <code>input</code> and the agent is invoked immediately.</p>

        <!-- Integrations -->
        <h3 id="integrations" class="mt-xl">Integrations</h3>
        <p>Integrations connect agents to external communication platforms. When configured, agents can receive messages from external sources and respond back through the same channel. Agent Orcha currently supports two integration types: <strong>Collabnook</strong> (real-time chat) and <strong>Email</strong> (IMAP/SMTP).</p>

        <p>Integrations are added to agents via the <code>integrations</code> field in the agent YAML. Each integration type injects its own input variables and tools into the agent automatically.</p>

        <h4 id="integration-collabnook">Collabnook</h4>
        <p><a href="https://collabnook.com" target="_blank" rel="noopener">Collabnook</a> is a minimalistic anonymous chat with audio and video calls &mdash; no sign-up required. The Collabnook integration connects to it via WebSocket. When active, the agent joins a channel and responds to @mentions in real time.</p>

        <h5>How It Works</h5>
        <ul>
          <li>The agent connects to the Collabnook server via WebSocket and joins the specified channel</li>
          <li>When a user @mentions the bot name, the agent is invoked with the message</li>
          <li>Recent channel messages and member lists are automatically injected as input variables (<code>channelContext</code>, <code>channelMembers</code>)</li>
          <li>The agent's response is posted back to the channel</li>
          <li>Combined with cron triggers, agents can also proactively monitor and respond to channel activity on a schedule</li>
        </ul>

        <h5>Schema</h5>
        <table>
          <thead>
            <tr>
              <th>Field</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>type</code></td>
              <td>string</td>
              <td><code>"collabnook"</code> (required)</td>
            </tr>
            <tr>
              <td><code>url</code></td>
              <td>string</td>
              <td>Collabnook server URL (required)</td>
            </tr>
            <tr>
              <td><code>channel</code></td>
              <td>string</td>
              <td>Channel to join (required)</td>
            </tr>
            <tr>
              <td><code>botName</code></td>
              <td>string</td>
              <td>Display name for the bot in the channel (required)</td>
            </tr>
            <tr>
              <td><code>password</code></td>
              <td>string</td>
              <td>Server password if authentication is required (optional)</td>
            </tr>
            <tr>
              <td><code>replyDelay</code></td>
              <td>number</td>
              <td>Delay in ms before posting the reply (optional)</td>
            </tr>
          </tbody>
        </table>

        <h5>Example</h5>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: channel-bot
description: Bot connected to a chat channel
llm: default

prompt:
  system: |
    You are a channel assistant.
    Use the channel context to respond to messages.
  inputVariables:
    - message
    - channelContext
    - channelMembers

integrations:
  - type: collabnook
    url: https://collabnook.example.com
    channel: general
    botName: orcha-bot</code></pre>
          </div>
        </div>

        <h5>Injected Input Variables</h5>
        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>channelContext</code></td>
              <td>Recent channel messages formatted as text</td>
            </tr>
            <tr>
              <td><code>channelMembers</code></td>
              <td>List of channel members with userId and name</td>
            </tr>
          </tbody>
        </table>

        <h4 id="integration-email">Email</h4>
        <p>Connect agents to email via IMAP polling (inbound) and SMTP (outbound). The agent polls a mailbox folder for new emails and is automatically invoked when one arrives. The agent's response is sent back to the original sender as a reply. Agents also receive an <code>email_send</code> tool for composing new outbound emails to any address.</p>

        <h5>How It Works</h5>
        <ul>
          <li>The agent connects to the IMAP server and polls the configured folder at a regular interval</li>
          <li>New (unseen) emails trigger the agent with the email content as input</li>
          <li>The agent's response is automatically sent back to the original sender via SMTP</li>
          <li>The agent also gets an <code>email_send</code> built-in tool for composing new emails to arbitrary recipients</li>
        </ul>

        <h5>Schema</h5>
        <table>
          <thead>
            <tr>
              <th>Field</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>type</code></td>
              <td>string</td>
              <td><code>"email"</code> (required)</td>
            </tr>
            <tr>
              <td><code>imap.host</code></td>
              <td>string</td>
              <td>IMAP server hostname (required)</td>
            </tr>
            <tr>
              <td><code>imap.port</code></td>
              <td>number</td>
              <td>IMAP port (default: 993)</td>
            </tr>
            <tr>
              <td><code>imap.secure</code></td>
              <td>boolean</td>
              <td>Use TLS for IMAP (default: true)</td>
            </tr>
            <tr>
              <td><code>smtp.host</code></td>
              <td>string</td>
              <td>SMTP server hostname (required)</td>
            </tr>
            <tr>
              <td><code>smtp.port</code></td>
              <td>number</td>
              <td>SMTP port (default: 587)</td>
            </tr>
            <tr>
              <td><code>smtp.secure</code></td>
              <td>boolean</td>
              <td>Use TLS for SMTP (default: false)</td>
            </tr>
            <tr>
              <td><code>auth.user</code></td>
              <td>string</td>
              <td>Email account username (optional)</td>
            </tr>
            <tr>
              <td><code>auth.pass</code></td>
              <td>string</td>
              <td>Email account password or app password (optional)</td>
            </tr>
            <tr>
              <td><code>fromName</code></td>
              <td>string</td>
              <td>Display name for outbound emails (optional)</td>
            </tr>
            <tr>
              <td><code>fromAddress</code></td>
              <td>string</td>
              <td>From address override &mdash; defaults to <code>auth.user</code> (optional)</td>
            </tr>
            <tr>
              <td><code>pollInterval</code></td>
              <td>number</td>
              <td>Seconds between mailbox checks (default: 60)</td>
            </tr>
            <tr>
              <td><code>folder</code></td>
              <td>string</td>
              <td>IMAP folder to monitor (default: INBOX)</td>
            </tr>
          </tbody>
        </table>

        <h5>Example</h5>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: support-agent
description: Handles inbound support emails
llm: default

prompt:
  system: |
    You are a customer support agent.
    Reply helpfully to inbound emails.
    Use the email_send tool if you need to
    contact other departments.
  inputVariables:
    - message

integrations:
  - type: email
    imap:
      host: imap.gmail.com
      port: 993
      secure: true
    smtp:
      host: smtp.gmail.com
      port: 587
      secure: false
    auth:
      user: support@example.com
      pass: app-password
    fromName: "Support Agent"
    pollInterval: 30
    folder: INBOX</code></pre>
          </div>
        </div>

        <h5>Injected Tools</h5>
        <table>
          <thead>
            <tr>
              <th>Tool</th>
              <th>Description</th>
              <th>Parameters</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>email_send</code></td>
              <td>Compose and send a new email</td>
              <td><code>to</code> (string), <code>subject</code> (string), <code>body</code> (string)</td>
            </tr>
          </tbody>
        </table>

        <h3 id="published-agents" class="mt-xl">Published Agents</h3>
        <p>Published agents get standalone chat pages accessible at <code>/chat/&lt;agent-name&gt;</code>, independent of the Studio UI. This is useful for sharing agents with end-users who don't need access to the full Studio interface.</p>

        <h4>Configuration</h4>
        <p>Add the <code>publish</code> field to any agent YAML file:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code># Simple &mdash; publish with no password
name: my-chatbot
description: A helpful assistant
llm: default
prompt:
  system: You are a helpful assistant.
  inputVariables:
    - message
publish: true</code></pre>
          </div>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code># With password protection
publish:
  enabled: true
  password: "secret123"</code></pre>
          </div>
        </div>

        <h4>How It Works</h4>
        <ul>
          <li>Visit <code>/chat/&lt;agent-name&gt;</code> to open the standalone chat page</li>
          <li>If password-protected, users must authenticate before chatting</li>
          <li>The password is per-agent and independent of the global <code>AUTH_PASSWORD</code></li>
          <li>The standalone page supports markdown rendering, code highlighting, thinking blocks, tool call visualization, and file attachments</li>
          <li>Sessions are ephemeral (per browser tab) and use <code>sessionStorage</code></li>
          <li>Unpublished agents and non-existent agents return a 404</li>
        </ul>

        <!-- Knowledge Stores -->
        <h2 id="knowledge-stores" class="mt-2xl">Knowledge Stores</h2>
        <img src="knowledge-architecture.svg" alt="Agent Orcha Knowledge Architecture" style="width:100%;margin:1.5rem 0;" />
        <p>Knowledge stores are one of the most powerful features of Agent Orcha and a key differentiator from other agentic frameworks. They combine <strong>semantic vector search</strong>, <strong>knowledge graphs</strong>, and <strong>direct SQL querying</strong> in a single unified system &mdash; all from a simple YAML definition.</p>

        <p>Most frameworks stop at basic RAG (embed chunks, search by similarity). Agent Orcha goes further:</p>
        <ul>
          <li><strong>Vector search</strong> &mdash; Semantic similarity search powered by SQLite + sqlite-vec. No external vector databases (Chroma, Pinecone, etc.) required.</li>
          <li><strong>Knowledge graphs</strong> &mdash; Build entity graphs from structured data via <code>directMapping</code>. Deterministic extraction from columns &mdash; no LLM calls, 100% data preservation.</li>
          <li><strong>Direct SQL querying</strong> &mdash; For database-backed stores (PostgreSQL, MySQL, SQLite), agents automatically get a readonly SQL tool to query the source data directly. This means agents can do precise filtering, aggregation, joins, and counts that semantic search alone cannot provide.</li>
          <li><strong>Zero-config persistence</strong> &mdash; All data is persisted to SQLite. On restart, unchanged stores restore instantly without re-indexing.</li>
        </ul>

        <h3 id="knowledge-schema">Knowledge Store Schema</h3>
        <p>All knowledge stores share a single unified schema. A store without <code>graph</code> does vector-only search; adding <code>graph.directMapping</code> enables entity extraction and graph traversal.</p>

        <h4>Schema</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="knowledge-schema">Copy</button>
          </div>
          <div class="code-content">
            <pre id="knowledge-schema"><code>name: string                    # Unique identifier (required)
description: string             # Human-readable description (required)

source:                         # Data source (required)
  type: directory | file | database | web
  # Web-specific options:
  selector: string              # CSS selector for html loader (optional)
  headers: { key: value }       # Custom/auth headers (optional)
  jsonPath: string              # Dot-notation path to extract nested array from JSON (optional)

loader:                         # Document loader (optional)
  type: text | pdf | csv | json | markdown | html
  # Defaults: html for web sources, text for file/directory
  # Not used for database sources (has its own row-to-document logic)

splitter:                       # Text chunking (required)
  type: character | recursive | token | markdown
  chunkSize: number             # Characters per chunk (default: 1000)
  chunkOverlap: number          # Overlap between chunks (default: 200)

embedding: string               # Reference to embedding config in llm.json (default: "default")

graph:                          # Optional - enables entity graph
  directMapping:                # Maps structured data to entities and relationships
    entities:
      - type: string            # Entity type name
        idColumn: string        # Column used as unique ID
        nameColumn: string      # Column used as display name (optional)
        properties: [string]    # Columns to include as entity properties
    relationships:              # Optional
      - type: string            # Relationship type name
        source: string          # Source entity type
        target: string          # Target entity type
        sourceIdColumn: string  # Column linking to source entity
        targetIdColumn: string  # Column linking to target entity

search:                         # Search configuration (optional)
  defaultK: number              # Results per search (default: 4)
  scoreThreshold: number        # Minimum similarity score (0-1)

reindex:                        # Periodic re-indexing (optional)
  schedule: string              # Cron expression (e.g., "0 * * * *" for hourly)</code></pre>
          </div>
        </div>

        <h4>Example: Vector-Only Store</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: docs
description: Documentation for semantic search

source:
  type: directory
  path: knowledge/sample-data
  pattern: "*.txt"

loader:
  type: text

splitter:
  type: character
  chunkSize: 1000
  chunkOverlap: 200

embedding: default

search:
  defaultK: 4
  scoreThreshold: 0.2</code></pre>
          </div>
        </div>

        <h3 id="direct-mapping" class="mt-xl">Direct Mapping (Graph)</h3>
        <p>Add a <code>graph.directMapping</code> section to build a knowledge graph from structured data (database, CSV, or JSON sources). Entities and relationships are mapped deterministically from columns/keys &mdash; no LLM calls during extraction, 100% data preservation.</p>

        <h4>Example: Blog Posts with Authors</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="direct-mapping-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="direct-mapping-example"><code>name: blog-posts
description: Blog posts with authors as a knowledge graph

source:
  type: database
  connectionString: postgresql://user:pass@localhost:5432/blog
  query: |
    SELECT p.id, p.title, p.slug, p.html AS content,
           u.name AS author_name, u.email AS author_email
    FROM posts p
    LEFT JOIN users u ON p.author_id = u.id
    WHERE p.status = 'published'
  contentColumn: content
  metadataColumns: [id, title, slug, author_name, author_email]

splitter:
  type: recursive
  chunkSize: 2000
  chunkOverlap: 300

embedding: default

graph:
  directMapping:
    entities:
      - type: Post
        idColumn: id
        nameColumn: title
        properties: [title, slug, content]

      - type: Author
        idColumn: author_email
        nameColumn: author_name
        properties: [author_name, author_email]

    relationships:
      - type: WROTE
        source: Author
        target: Post
        sourceIdColumn: author_email
        targetIdColumn: id

search:
  defaultK: 10</code></pre>
          </div>
        </div>

        <p>Each entity definition maps a row's columns to a graph node. The <code>idColumn</code> determines uniqueness (duplicate IDs are merged), <code>nameColumn</code> sets the display name, and <code>properties</code> lists which columns to attach as node properties. Relationships connect entities via their ID columns.</p>

        <h4>Example: Web JSON API with Graph</h4>
        <p>You can also build knowledge graphs from JSON API endpoints. When a JSON source contains an array of objects, each object is treated as a row with keys mapped to columns &mdash; just like database and CSV sources.</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: team-directory
description: Team members from internal API

source:
  type: web
  url: https://api.internal.com/v1/employees
  jsonPath: data.employees
  headers:
    Authorization: "Bearer ${EMPLOYEE_API_TOKEN}"

loader:
  type: json

splitter:
  type: character
  chunkSize: 500

embedding: default

graph:
  directMapping:
    entities:
      - type: Employee
        idColumn: id
        nameColumn: name
        properties: [name, email, role]
      - type: Department
        idColumn: department
        nameColumn: department
        properties: [department]
    relationships:
      - type: BELONGS_TO
        source: Employee
        target: Department
        sourceIdColumn: id
        targetIdColumn: department</code></pre>
          </div>
        </div>

        <h4>How It Works</h4>
        <ul>
          <li>All stores persist to SQLite via <code>.knowledge-data/{name}.db</code></li>
          <li>On startup, source hashes are compared &mdash; if unchanged, data is restored from SQLite without re-indexing</li>
          <li>Stores with <code>graph.directMapping</code> also store entities and relationships in SQLite, with vector embeddings for entity similarity search</li>
          <li>Agents get additional graph tools (traverse, entity_lookup, graph_schema) when entities exist</li>
        </ul>

        <h3 id="source-types" class="mt-xl">Source Types</h3>
        <p>All knowledge stores support the same source types for loading documents.</p>

        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Description</th>
              <th>Key Options</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>directory</code></td>
              <td>Load files from a local directory</td>
              <td><code>path</code>, <code>pattern</code> (glob), <code>recursive</code></td>
            </tr>
            <tr>
              <td><code>file</code></td>
              <td>Load a single file</td>
              <td><code>path</code></td>
            </tr>
            <tr>
              <td><code>database</code></td>
              <td>Query PostgreSQL, MySQL, or SQLite. Agents also get a readonly SQL tool for direct querying.</td>
              <td><code>connectionString</code>, <code>query</code>, <code>contentColumn</code>, <code>metadataColumns</code>, <code>batchSize</code></td>
            </tr>
            <tr>
              <td><code>web</code></td>
              <td>Fetch content from a URL (HTML, JSON, text, CSV)</td>
              <td><code>url</code>, <code>selector</code> (CSS, html only), <code>headers</code> (auth/custom), <code>jsonPath</code> (dot-notation for nested arrays)</td>
            </tr>
          </tbody>
        </table>

        <p>Paths for <code>directory</code> and <code>file</code> sources are relative to the project root.</p>

        <h3 id="loader-types" class="mt-xl">Loader Types</h3>
        <p>The <code>loader.type</code> determines how fetched content is parsed. It is optional &mdash; defaults to <code>html</code> for web sources and <code>text</code> for file/directory sources. Not used for database sources.</p>

        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Description</th>
              <th>Graph Support</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>html</code></td>
              <td>Parse HTML with Cheerio, optional CSS <code>selector</code>. Default for web sources.</td>
              <td>No</td>
            </tr>
            <tr>
              <td><code>text</code> / <code>markdown</code></td>
              <td>Raw text as a single document. Default for file/directory sources.</td>
              <td>No</td>
            </tr>
            <tr>
              <td><code>json</code></td>
              <td>Array of objects: each object becomes a row with <code>_rawRow</code> metadata. Other JSON: extracts all string values.</td>
              <td>Yes (array of objects)</td>
            </tr>
            <tr>
              <td><code>csv</code></td>
              <td>One document per row, formatted as "column: value" pairs with <code>_rawRow</code> metadata.</td>
              <td>Yes</td>
            </tr>
            <tr>
              <td><code>pdf</code></td>
              <td>Extract text from PDF files (requires <code>pdf-parse</code> package). File/directory only.</td>
              <td>No</td>
            </tr>
          </tbody>
        </table>

        <h3 id="search-configuration" class="mt-xl">Search Configuration</h3>
        <p>All stores use the same unified search pipeline:</p>
        <ol>
          <li>Embed the query using the configured embedding model</li>
          <li>Run KNN cosine similarity search against chunk vectors in SQLite</li>
          <li>If entities exist: also search entity vectors, then expand neighborhoods via graph traversal</li>
          <li>Merge all results by score, return top-K</li>
        </ol>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
            <button class="code-copy-btn" data-copy-target="search-config">Copy</button>
          </div>
          <div class="code-content">
            <pre id="search-config"><code>search:
  defaultK: 4                   # Results per search (default: 4)
  scoreThreshold: 0.2           # Minimum similarity score (optional)</code></pre>
          </div>
        </div>

        <h4>Scheduled Re-indexing</h4>
        <p>Knowledge stores can be configured to automatically re-index on a cron schedule. The cron checks source hashes and only re-indexes when the underlying data has changed.</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>reindex:
  schedule: "0 * * * *"         # Cron expression (e.g., every hour)</code></pre>
          </div>
        </div>

        <h4>Persistence</h4>
        <p>All data is persisted to SQLite at <code>.knowledge-data/{name}.db</code>. On server restart, source file hashes are compared &mdash; if nothing changed, the store is restored instantly from SQLite without re-embedding or re-extracting. To force a full rebuild, use the Re-index button in the Studio or call <code>POST /api/knowledge/:name/index</code>.</p>

        <h3 id="direct-sql-querying" class="mt-xl">Direct SQL Querying</h3>
        <p>For knowledge stores backed by a <code>database</code> source, agents automatically receive a readonly SQL tool (<code>knowledge_sql_{name}</code>) in addition to the semantic search tool. This lets agents query the source database directly using SQL &mdash; enabling precise filtering, aggregation, joins, and counts that vector search alone cannot provide.</p>

        <h4>How It Works</h4>
        <ul>
          <li>The SQL tool is auto-generated from the knowledge store's <code>source.query</code> &mdash; the agent sees the available tables and columns</li>
          <li>Only <code>SELECT</code> queries are allowed &mdash; <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and DDL statements are blocked</li>
          <li>Results are automatically limited (default 25 rows, max 100) to prevent runaway queries</li>
          <li>Supported databases: <strong>PostgreSQL</strong>, <strong>MySQL</strong>, and <strong>SQLite</strong></li>
        </ul>

        <h4>When to Use SQL vs Semantic Search</h4>
        <table>
          <thead>
            <tr>
              <th>Use Case</th>
              <th>Best Tool</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>"Find documents about customer satisfaction"</td>
              <td>Semantic search &mdash; meaning-based matching</td>
            </tr>
            <tr>
              <td>"How many orders were placed last month?"</td>
              <td>SQL &mdash; precise aggregation</td>
            </tr>
            <tr>
              <td>"Show me all calls handled by agent John"</td>
              <td>SQL &mdash; exact filtering</td>
            </tr>
            <tr>
              <td>"What topics come up most in support tickets?"</td>
              <td>Both &mdash; SQL for counts, semantic for themes</td>
            </tr>
          </tbody>
        </table>
        <p>The agent decides which tool to use based on the question. Having both available means agents can combine the precision of SQL with the flexibility of semantic search in a single conversation.</p>

        <h4>Example: SQLite Knowledge Store</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML</span>
          </div>
          <div class="code-content">
            <pre><code>name: music-store
description: Music catalog with artists, albums, and tracks

source:
  type: database
  connectionString: sqlite://knowledge/music-store/musicstore.sqlite
  query: |
    SELECT t.TrackId, t.Name AS track, a.Title AS album,
           ar.Name AS artist, g.Name AS genre, t.UnitPrice
    FROM tracks t
    JOIN albums a ON t.AlbumId = a.AlbumId
    JOIN artists ar ON a.ArtistId = ar.ArtistId
    JOIN genres g ON t.GenreId = g.GenreId
  contentColumn: track
  metadataColumns: [TrackId, album, artist, genre, UnitPrice]

splitter:
  type: character
  chunkSize: 500

embedding: default

graph:
  directMapping:
    entities:
      - type: Artist
        idColumn: artist
        nameColumn: artist
        properties: [artist]
      - type: Genre
        idColumn: genre
        nameColumn: genre
        properties: [genre]
    relationships:
      - type: PLAYS
        source: Artist
        target: Genre
        sourceIdColumn: artist
        targetIdColumn: genre</code></pre>
          </div>
        </div>
        <p>With this configuration, an agent can semantically search for "upbeat jazz tracks", run <code>SELECT artist, COUNT(*) FROM tracks GROUP BY artist ORDER BY COUNT(*) DESC LIMIT 5</code> to find the most prolific artists, and traverse the knowledge graph to discover genre relationships &mdash; all from the same knowledge store.</p>

        <!-- API Reference -->
        <h2 id="api-reference" class="mt-2xl">API Reference</h2>
        <p>Complete REST API documentation for interacting with agents, workflows, knowledge stores, functions, MCP servers, files, and LLMs.</p>

        <h3>Health Check</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">HTTP</span>
          </div>
          <div class="code-content">
            <pre><code>GET /health

Response:
{
  "status": "ok",
  "timestamp": "2026-01-21T12:00:00.000Z"
}</code></pre>
          </div>
        </div>

        <h3 id="auth-api" class="mt-xl">Authentication API</h3>
        <p>When the <code>AUTH_PASSWORD</code> environment variable is set, all <code>/api/*</code> routes require a valid session cookie. The <code>/health</code> endpoint is always public. When <code>AUTH_PASSWORD</code> is not set, authentication is disabled and all routes are open.</p>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/auth/check</code></td>
              <td>Check authentication status (never returns 401)</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/auth/login</code></td>
              <td>Authenticate with password, returns session cookie</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/auth/logout</code></td>
              <td>Invalidate session and clear cookie</td>
            </tr>
          </tbody>
        </table>

        <h4>Login</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">HTTP</span>
          </div>
          <div class="code-content">
            <pre><code>POST /api/auth/login
Content-Type: application/json

Request:
{
  "password": "your-secret-password"
}

Response (success — sets HttpOnly session cookie):
{
  "authenticated": true
}

Response (wrong password):
HTTP 401
{
  "error": "Invalid password"
}</code></pre>
          </div>
        </div>

        <h4>Check Auth Status</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">HTTP</span>
          </div>
          <div class="code-content">
            <pre><code>GET /api/auth/check

Response (auth enabled, not logged in):
{
  "authenticated": false,
  "required": true
}

Response (auth disabled):
{
  "authenticated": true,
  "required": false
}</code></pre>
          </div>
        </div>

        <h3 id="agents-api">Agents API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/agents</code></td>
              <td>List all agents</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/agents/:name</code></td>
              <td>Get agent details</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/agents/:name/invoke</code></td>
              <td>Run agent</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/agents/:name/stream</code></td>
              <td>Stream agent response (SSE)</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/agents/sessions/stats</code></td>
              <td>Get session statistics</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/agents/sessions/:sessionId</code></td>
              <td>Get session details</td>
            </tr>
            <tr>
              <td>DELETE</td>
              <td><code>/api/agents/sessions/:sessionId</code></td>
              <td>Clear session messages</td>
            </tr>
          </tbody>
        </table>

        <h4>Invoke Agent</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="agent-invoke">Copy</button>
          </div>
          <div class="code-content">
            <pre id="agent-invoke"><code>curl -X POST http://localhost:3000/api/agents/researcher/invoke \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "topic": "your topic"
    },
    "sessionId": "optional-session-id"
  }'</code></pre>
          </div>
        </div>

        <h4>Response</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JSON</span>
          </div>
          <div class="code-content">
            <pre><code>{
  "output": "Agent response text",
  "metadata": {
    "tokensUsed": 150,
    "toolCalls": [],
    "duration": 1234,
    "sessionId": "optional-session-id",
    "messagesInSession": 4,
    "structuredOutputValid": true
  }
}</code></pre>
          </div>
        </div>

        <h3 id="chat-api" class="mt-xl">Chat API (Published Agents)</h3>
        <p>These endpoints power the standalone chat pages for published agents. They are exempt from global <code>AUTH_PASSWORD</code> authentication and handle their own per-agent auth.</p>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/chat/:agentName</code></td>
              <td>Serve standalone chat page (HTML)</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/chat/:agentName/config</code></td>
              <td>Get published agent config (name, description, requiresPassword)</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/chat/:agentName/auth</code></td>
              <td>Authenticate with agent password, returns token</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/chat/:agentName/stream</code></td>
              <td>Stream agent response (SSE), requires <code>X-Chat-Token</code> header if password-protected</td>
            </tr>
          </tbody>
        </table>

        <h4>Authenticate</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code>curl -X POST http://localhost:3000/api/chat/my-agent/auth \
  -H "Content-Type: application/json" \
  -d '{ "password": "secret123" }'

# Response: { "token": "abc123..." }</code></pre>
          </div>
        </div>

        <h4>Stream (with token)</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
          </div>
          <div class="code-content">
            <pre><code>curl -N -X POST http://localhost:3000/api/chat/my-agent/stream \
  -H "Content-Type: application/json" \
  -H "X-Chat-Token: abc123..." \
  -d '{
    "input": { "message": "Hello!" },
    "sessionId": "optional-session-id"
  }'</code></pre>
          </div>
        </div>

        <h3 id="workflows-api" class="mt-xl">Workflows API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/workflows</code></td>
              <td>List all workflows</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/workflows/:name</code></td>
              <td>Get workflow details</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/workflows/:name/run</code></td>
              <td>Execute workflow</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/workflows/:name/stream</code></td>
              <td>Stream workflow execution (SSE)</td>
            </tr>
          </tbody>
        </table>

        <h4>Run Workflow</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="workflow-run">Copy</button>
          </div>
          <div class="code-content">
            <pre id="workflow-run"><code>curl -X POST http://localhost:3000/api/workflows/research-paper/run \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "topic": "research topic",
      "style": "professional"
    }
  }'</code></pre>
          </div>
        </div>

        <h3 id="knowledge-api" class="mt-xl">Knowledge API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/knowledge</code></td>
              <td>List all knowledge stores</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/knowledge/:name</code></td>
              <td>Get knowledge store config</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/knowledge/:name/search</code></td>
              <td>Search knowledge store</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/knowledge/:name/refresh</code></td>
              <td>Reload documents</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/knowledge/:name/add</code></td>
              <td>Add documents</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/knowledge/:name/entities</code></td>
              <td>Get graph entities</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/knowledge/:name/edges</code></td>
              <td>Get graph edges</td>
            </tr>
          </tbody>
        </table>

        <h4>Search Knowledge Store</h4>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="knowledge-search">Copy</button>
          </div>
          <div class="code-content">
            <pre id="knowledge-search"><code>curl -X POST http://localhost:3000/api/knowledge/docs/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "search term",
    "k": 4
  }'</code></pre>
          </div>
        </div>

        <h4>Add Documents to Knowledge Store</h4>
        <p>Dynamically add documents to a knowledge store without restarting the server. If the store isn't initialized, it will be created automatically.</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Bash</span>
            <button class="code-copy-btn" data-copy-target="knowledge-add">Copy</button>
          </div>
          <div class="code-content">
            <pre id="knowledge-add"><code>curl -X POST http://localhost:3000/api/knowledge/docs/add \
  -H "Content-Type: application/json" \
  -d '{
    "documents": [
      {
        "content": "Your document content here",
        "metadata": {
          "source": "api",
          "category": "example",
          "timestamp": "2026-01-29"
        }
      }
    ]
  }'</code></pre>
          </div>
        </div>
        <p>Response:</p>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JSON</span>
          </div>
          <div class="code-content">
            <pre><code>{
  "success": true,
  "added": 1
}</code></pre>
          </div>
        </div>
        <p><strong>Use cases:</strong></p>
        <ul>
          <li>Building knowledge stores incrementally from external sources</li>
          <li>Real-time ingestion of generated content</li>
          <li>Integrating with webhooks or external APIs</li>
          <li>Dynamic document addition without server restarts</li>
        </ul>

        <h3 id="functions-api" class="mt-xl">Functions API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/functions</code></td>
              <td>List all functions</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/functions/:name</code></td>
              <td>Get function details and schema</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/functions/:name/call</code></td>
              <td>Call a function</td>
            </tr>
          </tbody>
        </table>

        <h3 id="skills-api" class="mt-xl">Skills API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/skills</code></td>
              <td>List all skills (name, description)</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/skills/:name</code></td>
              <td>Get skill details (name, description, content)</td>
            </tr>
          </tbody>
        </table>

        <h3 id="tasks-api" class="mt-xl">Tasks API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/tasks</code></td>
              <td>List all tasks (filter by <code>?status=</code>, <code>?kind=</code>, <code>?target=</code>)</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/tasks/:id</code></td>
              <td>Get task status and result</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/tasks/agent</code></td>
              <td>Submit an agent task</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/tasks/workflow</code></td>
              <td>Submit a workflow task</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/tasks/:id/cancel</code></td>
              <td>Cancel a running task</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/tasks/:id/respond</code></td>
              <td>Respond to an input-required task (ReAct human-in-the-loop)</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/tasks/:id/stream</code></td>
              <td>Stream task status updates (SSE)</td>
            </tr>
          </tbody>
        </table>

        <h3 id="mcp-api" class="mt-xl">MCP API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/mcp</code></td>
              <td>List all MCP servers</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/mcp/:name</code></td>
              <td>Get MCP server config</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/mcp/:name/tools</code></td>
              <td>List tools from server</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/mcp/:name/call</code></td>
              <td>Call a tool on server</td>
            </tr>
          </tbody>
        </table>

        <h3 id="files-api" class="mt-xl">Files API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/files/tree</code></td>
              <td>Get project directory tree</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/files/read?path=...</code></td>
              <td>Read file contents</td>
            </tr>
            <tr>
              <td>PUT</td>
              <td><code>/api/files/write</code></td>
              <td>Write file contents (hot-reload)</td>
            </tr>
          </tbody>
        </table>

        <h3 id="llm-api" class="mt-xl">LLM API</h3>
        <table>
          <thead>
            <tr>
              <th>Method</th>
              <th>Endpoint</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>GET</td>
              <td><code>/api/llm</code></td>
              <td>List all LLM configurations</td>
            </tr>
            <tr>
              <td>GET</td>
              <td><code>/api/llm/:name</code></td>
              <td>Get LLM config details</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/llm/:name/chat</code></td>
              <td>Chat with LLM</td>
            </tr>
            <tr>
              <td>POST</td>
              <td><code>/api/llm/:name/stream</code></td>
              <td>Stream chat with LLM (SSE)</td>
            </tr>
          </tbody>
        </table>

        <!-- Examples -->
        <h2 id="examples" class="mt-2xl">Examples</h2>
        <p>Real-world examples to help you get started with common use cases.</p>

        <h3>Example 1: Corporate Assistant with Knowledge Graph</h3>
        <p>This example shows an agent using a knowledge store for org chart queries with PII protection.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - agents/corporate.agent.yaml</span>
            <button class="code-copy-btn" data-copy-target="corporate-agent">Copy</button>
          </div>
          <div class="code-content">
            <pre id="corporate-agent"><code>name: corporate
description: Friendly corporate assistant — answers questions about the org, people, departments
version: "1.0.0"

llm:
  name: default
  temperature: 0.3

prompt:
  system: |
    You are Orcha, a friendly corporate assistant. You help employees find information
    about teams, people, projects, and the organization.
  inputVariables:
    - query

tools:
  - knowledge:org-chart

publish:
  enabled: true

memory:
  enabled: true
  maxLines: 50

output:
  format: text</code></pre>
          </div>
        </div>

        <h3 class="mt-xl">Example 2: Multi-Step Workflow</h3>
        <p>Orchestrating multiple agents to complete a complex task.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - workflows/example.workflow.yaml</span>
            <button class="code-copy-btn" data-copy-target="example-workflow">Copy</button>
          </div>
          <div class="code-content">
            <pre id="example-workflow"><code>name: example-workflow
description: A workflow demonstrating multi-agent orchestration
version: "1.0.0"

input:
  schema:
    topic:
      type: string
      required: true
      description: The topic to process

steps:
  - id: get-time
    agent: time
    input:
      timezone: "America/New_York"
    output:
      key: current_time

  - id: search-knowledge
    agent: knowledge
    input:
      query: "{{input.topic}}"
    output:
      key: knowledge_result

  - id: summarize
    agent: example
    input:
      query: |
        Summarize: {{steps.get-time.output}}
        Topic: {{input.topic}}
        Knowledge: {{steps.search-knowledge.output}}
    output:
      key: final_summary

config:
  timeout: 300000
  onError: stop

output:
  timestamp: "{{steps.get-time.output}}"
  knowledge: "{{steps.search-knowledge.output}}"
  summary: "{{steps.summarize.output}}"</code></pre>
          </div>
        </div>

        <h3 class="mt-xl">Example 3: Knowledge Store for RAG</h3>
        <p>Setting up semantic search with a knowledge store. All data is persisted to SQLite automatically.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - knowledge/docs.knowledge.yaml</span>
            <button class="code-copy-btn" data-copy-target="knowledge-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="knowledge-example"><code>name: docs
description: Knowledge base for semantic search

source:
  type: directory
  path: knowledge/sample-data
  pattern: "*.txt"

loader:
  type: text

splitter:
  type: character
  chunkSize: 1000
  chunkOverlap: 200

embedding: default

search:
  defaultK: 4
  scoreThreshold: 0.2</code></pre>
          </div>
        </div>

        <h3 class="mt-xl">Example 4: ReAct Workflow</h3>
        <p>An autonomous workflow using the ReAct pattern with automatic tool and agent discovery.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - workflows/research.workflow.yaml</span>
            <button class="code-copy-btn" data-copy-target="react-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="react-example"><code>name: react-research
description: Autonomous research using tool discovery
version: "1.0.0"
type: react

input:
  schema:
    topic:
      type: string
      required: true

prompt:
  system: |
    You are a research assistant with access to tools and agents.
    Identify all tools you need, call them in parallel,
    then synthesize results into a comprehensive report.
  goal: "Research and analyze: {{input.topic}}"

graph:
  model: default
  executionMode: single-turn
  tools:
    mode: all
    sources: [mcp, knowledge, function, builtin]
  agents:
    mode: all
  maxIterations: 10
  timeout: 300000

output:
  analysis: "{{state.messages[-1].content}}"</code></pre>
          </div>
        </div>

        <h3 class="mt-xl">Example 5: Knowledge Store with Graph</h3>
        <p>Building a knowledge graph from a CSV file using direct mapping. Entities and relationships are extracted deterministically from columns.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - knowledge/org-chart.knowledge.yaml</span>
            <button class="code-copy-btn" data-copy-target="graphrag-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="graphrag-example"><code>name: org-chart
description: Company org chart with personnel directory and performance reviews

source:
  type: file
  path: knowledge/org-chart/personnel.csv

loader:
  type: csv

splitter:
  type: character
  chunkSize: 800
  chunkOverlap: 0

embedding: default

search:
  defaultK: 5

graph:
  directMapping:
    entities:
      - type: Department
        idColumn: department_id
        nameColumn: department_name
        properties: []

      - type: Employee
        idColumn: employee_id
        nameColumn: employee_name
        properties:
          - title
          - location
          - hire_date
          - status
          - rating

    relationships:
      - type: WORKS_IN
        source: Employee
        target: Department
        sourceIdColumn: employee_id
        targetIdColumn: department_id

      - type: REPORTS_TO
        source: Employee
        target: Employee
        sourceIdColumn: employee_id
        targetIdColumn: manager_id</code></pre>
          </div>
        </div>

        <h3 class="mt-xl">Example 6: Music Librarian with Knowledge Graph and Email</h3>
        <p>An agent that explores a music catalog via knowledge graph and handles email inquiries.</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">YAML - agents/music-librarian.agent.yaml</span>
            <button class="code-copy-btn" data-copy-target="music-librarian-example">Copy</button>
          </div>
          <div class="code-content">
            <pre id="music-librarian-example"><code>name: music-librarian
description: Music store expert — explore the catalog, discover artists, and analyze customer listening patterns
version: "1.0.0"

llm:
  name: default
  temperature: 0.6

prompt:
  system: |
    You are a Music Librarian for a digital music store. You have deep access to the store's
    full catalog and purchase history through a knowledge graph.
    Use semantic search, entity lookup, and graph traversal to answer questions.
  inputVariables:
    - query

tools:
  - knowledge:music-store

integrations:
  - type: email
    imap:
      host: mail.example.com
      port: 993
      secure: true
    smtp:
      host: mail.example.com
      port: 587
      secure: false
    auth:
      user: librarian
      pass: secret
    fromName: "Music Librarian"
    fromAddress: librarian@example.com
    pollInterval: 20

memory:
  enabled: true
  maxLines: 50

publish:
  enabled: true</code></pre>
          </div>
        </div>

      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <h4>Product</h4>
          <ul class="footer-links">
            <li><a href="documentation.html">Documentation</a></li>
            <li><a href="documentation.html#quick-start">Quick Start</a></li>
            <li><a href="documentation.html#examples">Examples</a></li>
            <li><a href="documentation.html#api-reference">API Reference</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>Community</h4>
          <ul class="footer-links">
            <li><a href="https://github.com/ddalcu/agent-orcha" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> GitHub</a></li>
            <li><a href="https://github.com/ddalcu/agent-orcha/issues" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> Issues</a></li>
            <li><a href="https://github.com/ddalcu/agent-orcha/discussions" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> Discussions</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>Resources</h4>
          <ul class="footer-links">
            <li><a href="https://www.npmjs.com/package/agent-orcha" target="_blank" rel="noopener"><i class="fa-brands fa-npm"></i> NPM Package</a></li>
            <li><a href="https://github.com/ddalcu/agent-orcha/blob/main/README.md" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> README</a></li>
            <li><a href="https://github.com/ddalcu/agent-orcha/blob/main/LICENSE" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> License</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>About</h4>
          <ul class="footer-links">
            <li><a href="https://github.com/ddalcu" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> Author</a></li>
            <li>Version 0.0.5</li>
            <li>MIT License</li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2026 Agent Orcha. Released under the MIT License. 100% open source and forever free.</p>
      </div>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="assets/js/main.js"></script>
  <script src="assets/js/code-copy.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    document.querySelectorAll('.code-block').forEach(function(block) {
      var langLabel = block.querySelector('.code-language');
      var codeEl = block.querySelector('code');
      if (langLabel && codeEl) {
        var text = langLabel.textContent.trim().toLowerCase();
        var lang;
        if (text.includes('yaml')) lang = 'yaml';
        else if (text.includes('json')) lang = 'json';
        else if (text.includes('bash')) lang = 'bash';
        else if (text.includes('javascript') || text.includes('js')) lang = 'javascript';
        else if (text.includes('http')) lang = 'http';
        if (lang) codeEl.classList.add('language-' + lang);
      }
    });
    hljs.highlightAll();
  </script>
</body>
</html>
